/**
 * jsondiffpatch - Simplified version for PlumAI
 * Based on fast-json-patch RFC 6902 concepts
 * Optimized for version control with snapshots + deltas
 */
(function(global) {
    'use strict';

    const jsondiffpatch = {
        /**
         * Create a diff between two objects (delta/patch)
         * Returns only the changes needed to transform left into right
         */
        diff: function(left, right, path = '') {
            // Si son iguales, no hay cambios
            if (JSON.stringify(left) === JSON.stringify(right)) {
                return null;
            }

            const delta = {};

            // Si uno es null/undefined
            if (left == null || right == null) {
                if (left !== right) {
                    return { _t: 'replace', _v: right };
                }
                return null;
            }

            // Si son tipos diferentes
            if (typeof left !== typeof right) {
                return { _t: 'replace', _v: right };
            }

            // Si son primitivos
            if (typeof right !== 'object') {
                if (left !== right) {
                    return { _t: 'replace', _v: right };
                }
                return null;
            }

            // Si son arrays
            if (Array.isArray(right)) {
                if (!Array.isArray(left)) {
                    return { _t: 'replace', _v: right };
                }
                return this._diffArray(left, right);
            }

            // Si son objetos
            return this._diffObject(left, right);
        },

        _diffObject: function(left, right) {
            const delta = {};
            let hasChanges = false;

            // Verificar propiedades eliminadas
            for (const key in left) {
                if (!(key in right)) {
                    delta[key] = { _t: 'delete' };
                    hasChanges = true;
                }
            }

            // Verificar propiedades agregadas o modificadas
            for (const key in right) {
                if (!(key in left)) {
                    // Propiedad nueva
                    delta[key] = { _t: 'add', _v: right[key] };
                    hasChanges = true;
                } else {
                    // Propiedad existente, verificar cambios
                    const childDelta = this.diff(left[key], right[key]);
                    if (childDelta !== null) {
                        delta[key] = childDelta;
                        hasChanges = true;
                    }
                }
            }

            return hasChanges ? delta : null;
        },

        _diffArray: function(left, right) {
            // Para arrays, usamos una estrategia simple:
            // Si tienen diferente longitud o elementos diferentes, reemplazar completo
            if (left.length !== right.length) {
                return { _t: 'replace', _v: right };
            }

            // Verificar cada elemento
            let hasChanges = false;
            const delta = { _t: 'array' };

            for (let i = 0; i < right.length; i++) {
                const itemDelta = this.diff(left[i], right[i]);
                if (itemDelta !== null) {
                    delta[i] = itemDelta;
                    hasChanges = true;
                }
            }

            return hasChanges ? delta : null;
        },

        /**
         * Apply a delta to an object to get the new state
         */
        patch: function(left, delta) {
            if (delta === null) {
                return left;
            }

            // Si es un reemplazo simple
            if (delta._t === 'replace') {
                return delta._v;
            }

            // Si es una adición
            if (delta._t === 'add') {
                return delta._v;
            }

            // Si es una eliminación
            if (delta._t === 'delete') {
                return undefined;
            }

            // Si es un array
            if (delta._t === 'array') {
                const result = JSON.parse(JSON.stringify(left)); // Clone
                for (const key in delta) {
                    if (key !== '_t') {
                        const index = parseInt(key);
                        result[index] = this.patch(result[index], delta[key]);
                    }
                }
                return result;
            }

            // Si es un objeto
            const result = JSON.parse(JSON.stringify(left)); // Clone
            for (const key in delta) {
                if (delta[key]._t === 'delete') {
                    delete result[key];
                } else if (delta[key]._t === 'add') {
                    result[key] = delta[key]._v;
                } else {
                    result[key] = this.patch(result[key], delta[key]);
                }
            }

            return result;
        },

        /**
         * Reverse a delta (for undo operations)
         */
        unpatch: function(right, delta) {
            // Para simplificar, no implementamos unpatch completo
            // En vez de eso, guardamos snapshots periódicos
            throw new Error('unpatch not implemented - use snapshots for undo');
        },

        /**
         * Clone an object deeply
         */
        clone: function(obj) {
            return JSON.parse(JSON.stringify(obj));
        }
    };

    // Export
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = jsondiffpatch;
    } else {
        global.jsondiffpatch = jsondiffpatch;
    }

})(typeof window !== 'undefined' ? window : global);
